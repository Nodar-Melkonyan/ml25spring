#ქვემოთ მოცემული კოდი რამდენიმე მიმდევრობას შორის მსგავსებას ახალ მიმდევრობაში ძველის მისაღებად
#განსახორციელებელი ცვლილებების რიცხვით აფასებს
def find_similarity (seq1, seq2):
    #სიგრძეებისთვის ცალკე ცვლადების შეტანა (მათი ხშირად გამოყენების გამო)
    l_seq1 = len(seq1)
    l_seq2 = len(seq2)
    #ნულოვანი 2D-მატრიცის შექმნა ცვლილებების რიცხვების შესანახად
    mat = [[0] * (l_seq2 + 2) for _ in range (l_seq1 + 2)]

    #მქსიმალური მნიშვნელობა Base Case-ისთვის
    max_value = l_seq1 + l_seq2
    mat[0][0] = max_value

    #Base Case
    for i in range (1, l_seq1 + 2):
        mat[i][0] = max_value
        mat[i][1] = i - 1
    for j in range (1, l_seq2 + 2):
        mat[0][j] = max_value
        mat[1][j] = j - 1


    #ლექსიკონი იმისათვის, რომ გავიგოთ, მეორე მიმდევრობის სიმბოლოები ბოლოს სად იქნენ ნანახი პირველ მიმდევრობაში (ტრანსპოზიციისთვის, რომელიც ორ ჩანაცვლებაზე მოქნილია)
    last_pos = {}        

    #იწყება ყველა სიმბოლოს გავლა
    for i in range(1, l_seq1 + 1):
        last_match_in_seq2 = 0                 #ბოლო დამთხვეული სიმბოლო მეორე თანმიმდევრობაში (რათა ტრანსპოზიცია მხოლოდ ორ მეზობელ სიმბოლოს შორის მოხდეს)
        for j in range(1, l_seq2 + 1):
            i1 = last_pos.get(seq2[j - 1], 0)
            j1 = last_match_in_seq2

            #თუ სიმბოლოები ემთხვევა — 0, სხვა შემთხვევაში — 1.
            edit_value = 0 if seq1[i - 1] == seq2[j - 1] else 1

            #თუ სიმბოლოები დაემთხვეა, ციკლი გრძელდება
            if edit_value == 0:
                last_match_in_seq2 = j


            #მინიმალური ცვლილებების მნიშვნელობის დათვლა თითოეული წყვილისთვის და მინიმალურის არჩევა
            mat[i + 1][j + 1] = min(
                mat[i][j] + edit_value,                             #ჩანაცვლება/დამთხვევა
                mat[i + 1][j] + 1,                                  #ჩასმა
                mat[i][j + 1] + 1,                                  #წაშლა
                mat[i1][j1] + (i - i1 - 1) + 1 + (j - j1 - 1)       #ტრანსპოზიცია
            )


            last_pos[seq1[i - 1]] = i

    return mat[l_seq1 + 1][l_seq2 + 1]

#მაგალითი
seq1 = "სახლი"
sequences = ["laptop", "hierarchy", "ლხასი", "apple"]

for seq2 in sequences:
    value = find_similarity(seq1, seq2)
    print(f"ცვლილებების მინიმალური მნიშვნელობა '{seq1}-სა' და '{seq2}-ს' შორის არის {value}")
